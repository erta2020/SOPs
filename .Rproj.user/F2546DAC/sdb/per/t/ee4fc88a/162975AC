{
    "collab_server" : "",
    "contents" : "---\ntitle: \"USDA Particle Size Analysis\"\nauthor: \"Marc and Isaac\"\ndate: \"June 17, 2016\"\noutput: word_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\n## R Markdown\n\n\n### Importing Data\n\nThe imported files must have the same fields as the Rcode. We should create a screen that ensures fidelity between csv fields and R code variable expectations, but that will be another project.\n\nAt this point, we will have two files coming from the data entry forms created by Todd Shimoda.\n\n\n\n```{r importing}\n# This path is for marc's computer\n#file=\"/home/CAMPUS/mwl04747/github/SOPs/32_Soil_Texture_Analysis/IsaacsWork/HydrometerData--Corrected.csv\"\n\n# Path for marc when he is at home...\n\nfile = \"/home/CAMPUS/mwl04747/github/SOPs/32_Soil_Texture_Analysis/IsaacsWork/HydrometerData--Rearranged2.csv\"\n\n#This path is for Isaac's computer...\n#file=\"/Users/Chuck/Documents/SeniorYear/Thesis/Data/HydrometerData--Corrected.csv\"\n\n#This path for the computer in the lab (in Isaac's workspace)\n#file.choose()\n#file=\"C:\\\\Users\\\\im022012\\\\Documents\\\\HydrometerData\\\\Hydrometer--Rearranged.csv\"\nimport = read.csv(file)\nstr(import)\n\n```\n\n## Creating a Unique Identifier for each farm/date\n\n```{r }\n# Test\n# paste(import$Site, import$Location, import$SampleDate)\n\n# Create new id!\nFarmID=paste(import$Site, import$Location, import$SampleDate)\nimport$FarmID<-FarmID\n```\n\n\n## Calculate Rc\n\nOne of the first things we do is correct the hydrometer reading for certain biases. These biases come from density changes of the dispersing fluid as a result of the density of the despersing solution or changes in the solution temperature. \n\nThe formula is...\n\n$Rc = Ra - (Rb -1)$\n\n```{r calculatingRc, echo=FALSE }\n#redo rc time for each column\n# code for the old csv file...import$Rc30s = import$X30s - (import$Blank0s -1)\n# this is the code that didnt work on the rearranged file (which you now call \"corrected\") import$Rc = import$Ractual - (import$Rblank -1)\n#to get rid of the NAs we want to create a unique ID\n\n\n```\n\n\n## Subset Test to Process One Farm before we create a loop to process all farms.\n\n```{r subsetdata}\n# subset(import, subset=FarmID==\"Zamo 4-7F 7/7/2015\" )\n\nTest<- subset(import, subset=FarmID==\"Zamo 4-7F 7/7/2015\" )\n```\n\n\n## Filling NA Blanks and Temperatures.\n\n# Convert all times to minutes\n\nWe will used $Et$ for elapsed time in R after this conversion:\n\n```{r converttimes}\nElapsedTimeConversion <- function(units = \"m\"){\n  ifelse(units == \"s\", 1/60, \n  ifelse(units == \"m\", 1/1, \n  ifelse(units == \"h\", 60/1, \n  ifelse(units == NA, 0))))\n}\n  \nTest$Et <- Test$Elapsed_Time * with(Test, ElapsedTimeConversion(Et_Units)); Test$Et\n```\n\n# Table for Blanks Alignments\n\nWe will align missing values to closest readings: \n\n| Reading | Missing Range |\n| --------| ------------- | \n| 0       | 0-30          |\n| 60      | 31-90         |\n| 120     | 91-240        |\n| 1440    | >240          |\n\nI would like to create a more autmotic function for this, but I couldn't figure this out in an elegant way!\n\n```{r Et_alignments}\nEt_aligning <- function(Et){\n  ifelse(Et > 800, 1440,\n  ifelse(Et > 90, 120,\n  ifelse(Et > 30, 60,\n  ifelse(Et >= 0, 0,\n  ifelse(Et == NA, NA)))))\n}\n\n# Test function\nEt_aligning(c(0.5, 2, 30,60, 150, 1440))\n\n```\n\n## Using Non-Missing to Impute Missing Temp and RBlank\n\nI still believe there is a more elegant to do this, but this is better than my initial idea!\n\n### Ways to Improve the Function:\n\nFirst, we could make the function that address both missing values simultaneously. For example, impute(sampleID, parameter)...\n\nI tried this, but ran into the problem that we use different columns that are identified in differeing ways. Perhaps, next week!\n\n\n```{r imputing}\n\nimputeT <- function(sampleID){\n library(dplyr)\n tmp <- sampleID %>% select(Et, Rblank, Temp)\n tmp$Et_Align <- Et_aligning(Test$Et) \n\n # non missing, keeping Rblank and Et_Align\n  nonmissingR = tmp[!is.na(tmp$Rblank),c(2,4)]; nonmissingR \n  missingR = tmp[is.na(tmp$Rblank),c(2,4)]; missingR\n  nonmissingT = tmp[!is.na(tmp$Temp),c(3,4)]; nonmissingT\n  missingT = tmp[is.na(tmp$Temp),c(3,4)]; missingT\n\ntmpR = left_join(missingR, nonmissingR, by=\"Et_Align\")\ntmpT = left_join(missingT, nonmissingT, by=\"Et_Align\")\n\n#sampleID$Rblank[is.na(Test$Rblank)] <- tmpR$Rblank.y; \n#sampleID$Temp[is.na(Test$Temp)] <- \n# tmpR$Rblank.y\ntmpT$Temp.y\n}\n\nimputeR <- function(sampleID){\n library(dplyr)\n tmp <- sampleID %>% select(Et, Rblank, Temp)\n tmp$Et_Align <- Et_aligning(Test$Et) \n\n # non missing, keeping Rblank and Et_Align\n  nonmissingR = tmp[!is.na(tmp$Rblank),c(2,4)]; nonmissingR \n  missingR = tmp[is.na(tmp$Rblank),c(2,4)]; missingR\n  nonmissingT = tmp[!is.na(tmp$Temp),c(3,4)]; nonmissingT\n  missingT = tmp[is.na(tmp$Temp),c(3,4)]; missingT\n\ntmpR = left_join(missingR, nonmissingR, by=\"Et_Align\")\ntmpT = left_join(missingT, nonmissingT, by=\"Et_Align\")\n\n#sampleID$Rblank[is.na(Test$Rblank)] <- tmpR$Rblank.y; \n#sampleID$Temp[is.na(Test$Temp)] <- \n# tmpR$Rblank.y\ntmpR$Rblank.y\n}\n\nhead(Test)\nTest$Temp[is.na(Test$Temp)] <- imputeT(Test)\nTest$Rblank[is.na(Test$Rblank)] <- imputeR(Test)\nhead(Test)\n\n```\n\n### Old Section Removed!\n\nThis was a long and tedious approach...\n```{r Oldsection}\n#now we want to try and calculate the Rcs for one farm at a time and deal with the blanks\n\n#(checking that this cross references to get only one object in the vector in the subset)Test$Rblank[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Rblank[Test$Elapsed_Time==30 & Test$Et_Units==\"s\"]\n\n#Test$Rblank[Test$Elapsed_Time==30 & Test$Et_Units==\"s\"]<- Test$Rblank[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test\n#Test,Rblank[Elapsed_Time==30 & Et_Units==\"s\"]\n#<-Rblank[Elapsed_Time==0 & Et_Units==\"s\"] )\n#Test,Rblank[Elapsed_Time==60 & Et_Units==\"s\"]\n#<-Rblank[Elapsed_Time==0 & Et_Units==\"s\"] )\n#Test$Rblank[Test$Elapsed_Time==60 & Test$Et_Units==\"s\"]<- Test$Rblank[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Rblank[Test$Elapsed_Time==3 & Test$Et_Units==\"m\"]<- Test$Rblank[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Rblank[Test$Elapsed_Time==10 & Test$Et_Units==\"m\"]<- Test$Rblank[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Rblank[Test$Elapsed_Time==30 & Test$Et_Units==\"m\"]<- Test$Rblank[Test$Elapsed_Time==60 & Test$Et_Units==\"m\"]\n#Test$Rblank[Test$Elapsed_Time==90 & Test$Et_Units==\"m\"]<- Test$Rblank[Test$Elapsed_Time==60 & Test$Et_Units==\"m\"]\n#Test\n#Test$Rblank\n```\n\n## RcTest\n\nNot sure what we are doing here... Isaac, can you comment?\n\n```{r RcTest}\nTest$RcTest<- Test$Ractual - (Test$Rblank - 1)\n\n#We still have one NA because of the temp at 0\n```\n\n\n## Old Way Of Imputing Temp!\n\nRemoved... thank goodness!\n```{r}\n#Assigning values to missing #'s in Temp Column\n#Test$Temp[Test$Elapsed_Time==30 & Test$Et_Units==\"s\"]<-Test$Temp[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Temp[Test$Elapsed_Time==60 & Test$Et_Units==\"s\"]<-Test$Temp[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Temp[Test$Elapsed_Time==3 & Test$Et_Units==\"m\"]<-Test$Temp[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Temp[Test$Elapsed_Time==10 & Test$Et_Units==\"m\"]<-Test$Temp[Test$Elapsed_Time==0 & Test$Et_Units==\"s\"]\n#Test$Temp[Test$Elapsed_Time==30 & Test$Et_Units==\"m\"]<-Test$Temp[Test$Elapsed_Time==60 & Test$Et_Units==\"m\"]\n#Test$Temp[Test$Elapsed_Time==90 & Test$Et_Units==\"m\"]<-Test$Temp[Test$Elapsed_Time==60 & Test$Et_Units==\"m\"]\n#Test\n```\n\n## Calculating K\n\n```{r calculatingK}\nKfun <- function(T=22, GSp = 2.65){\n  ifelse(T < 20, NA, \n  ifelse(T  == 20, 0.01365, \n  ifelse(T  == 21, 0.01348, \n  ifelse(T  == 22, 0.01332,\n  ifelse(T  == 23, 0.01317,\n  ifelse(T  == 24, 0.01301,\n  ifelse(T  == 25, 0.01289,\n  ifelse(T > 25, NA, NA))))))))\n}\n\nTest$K <- Kfun(round(Test$Temp,0)); head(Test)\n\n```\n\n\n## Calculate Effective Depth\n\nWe need some explanation of this! I can't remember what we are doing here...\n\n```{r}\nx = c(1.00, 1.07)\ny = c(15.5, 0.6)\n\nL2coef = coef(lm(y~x))\n\n\nL1 = Test$RcTest * L2coef[2] + L2coef[1]\nL2 = 14.5\nVb = 40\nA = 27.8\nTest$Leff = L1 + 0.5*(L2-(Vb/A)); Test$Leff\nTest\n\n```\n## Calculate D\nAccording to ASTM D422-63 the equation to calculate D (diameter in mm) can be  simplified as D = K*sqrt(L/T) where: L=effective depth (Leff), T = measurment time in min and K is the constant given in the tables that varies with temperature (already calculated).\n\n```{r}\n#To perform the calculation the way described below we need time in minutes, which what is Et now! :-)\n\n#Tmin<- c(NA, 0.5, 1, 3, 10, 30, 60, 90, 120, 1440)\n#Test$Tmin<- Tmin\n\n#\nTest$D<-Test$K * sqrt(Test$Leff/Test$Et)\nTest$D\n```\n\n## Calculate PF\n\nP=[(100,000/w)*G/(G-G1)]*(R-G1) (pretty sure G1=1, pretty sure R = Rc (ask marc about this one)) and G=2.65 g/cm^3 (ask marc about this one too)\n\nThe bracketed portion will be the same for all variables thus we can calculate it separately and call it p1 (1st part of equation for )\n```{r}\nTest$PF= ((100000/Test$Wsair)*(2.65/(2.65-1)))*(Test$Rc - 1)\n```\n\n## Creating Figures\n\nYou can also embed plots, for example:\n\n```{r figure, echo=T}\nplot(x=log(Test$D), y=Test$PF, xlab=\"Log of Diameter (mm)\", ylab=\"Percent Finer\", las=1)\n```\n\n\n## Creating a Loop--Processing Multiple Sites\nWe should probably change this to SampleID...\n\n```{r loop}\n\nfor (year in c(2010,2011,2012,2013,2014,2015)){\n  print(paste(\"The year is\", year))\n}\n\nfarms <- unique(import$FarmID)\n\nfor(i in 1:length(farms)){\n  # All the business goes here! \n  # But it would be nice to create functions...\n  # more soon...\n  print(i); print(farms[i])\n}\n\n```\n\n\n## Creating a loop that is capable to writing a csv file that summarizes the appropriate data\\ldots\n\nFastest method: not yet implemented:\n\nd = data.frame( x=rep(0, 10), y=rep(0,10), z=rep(0,10))\n\nAnd in the loop (index i):\n\nd[i, ] = c(x, y, z)\n\n```{r loopwrite}\njunk=NULL\n\nfor(i in 1:length(farms)){\n  # create a dataframe...\n  junk = rbind(junk, data.frame(Obs=i, farm = import$FarmID[i]))\n}\nhead(junk)\nwrite.csv(junk, \"output_test.csv\")\n```\n",
    "created" : 1471126148193.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3236989035",
    "id" : "162975AC",
    "lastKnownWriteTime" : 1471144209,
    "last_content_update" : 1471144209857,
    "path" : "~/github/SOPs/32_Soil_Texture_Analysis/IsaacsWork/USDA Particle Size Analysis.Rmd",
    "project_path" : "32_Soil_Texture_Analysis/IsaacsWork/USDA Particle Size Analysis.Rmd",
    "properties" : {
        "chunk_rendered_width" : "-22",
        "last_setup_crc32" : "ee4fc88abb338d19"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}