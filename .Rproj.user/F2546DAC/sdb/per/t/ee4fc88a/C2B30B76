{
    "collab_server" : "",
    "contents" : "# Function to Calculate Ws \nSoilEquiv = function(tin, airdry, ovendry, tinmass, desiredmass = 50){\n  hygro = round(ovendry/airdry, 2)\n  wd = (airdry - ovendry)/(ovendry-tinmass)\n  WS_e = round(desiredmass * (1 + wd), 2)\n  output = data.frame(\n    Parameter = c(\"Tin ID\", \"Tin Tare Weight\", \"Mass of air-dried soil\", \n                  \"Mass of oven-dried soil\", \"Hygroscopic Correction Factor\", \n                  \"Desired Oven-dried Soil\", \"Effective Soil Weight (WSe)\"),\n    Value = c(tin, tinmass, airdry, ovendry, hygro, desiredmass, WS_e),\n    Box = c(12, 13, 14, 15, 17, 9, 18))\n  print(output)\n}\n\n# Function to Calculate Hygroscopic Water\nhygro = function(airdry, ovendry, tinmass){\n  hygro = round(ovendry/airdry, 2) \n}\n\n# Function to calculate Effective Soil Weight\nWS_e = function(airdry, ovendry, tinmass, actualsoilmass){\n  moisture_content = (airdry - ovendry)/(ovendry-tinmass)\n  round(actualsoilmass * (1 + moisture_content), 2)\n}\n\n# Functions for Readings\n\n# Time Conversation\nElapsedTimeConversion <- function(units){\n  ifelse(units == \"sec\", 1/60, \n  ifelse(units == \"min\", 1/1, \n  ifelse(units == \"hour\", 60/1, \n  ifelse(units == NA, NA))))\n}\n\n\n# Function to impute Blanks and Temp between Readings\n#-----------------------------------------------------\n# Align Missing with Non-Missing\nEt_aligning <- function(Et){\n  ifelse(Et > 800, 1440,\n  ifelse(Et > 90, 120,\n  ifelse(Et > 30, 60,\n  ifelse(Et >= 0, 0,\n  ifelse(Et == NA, NA)))))\n}\n\n# Test function\nEt_aligning(c(0.5, 2, 30,60, 150, 1440))\n\n# Function to Impute Temperature\nimputeT <- function(sampleID){\n  library(dplyr)\n  tmp2 <- sampleID %>% select(Et, blank, temp)\n  #tmp2 <- tmp %>% select(Et, blank, temp); tmp2\n  \n  missingT = tmp2[is.na(tmp2$temp),]; missingT\n  nonmissingT = tmp2[!is.na(tmp2$temp),]; nonmissingT\n  \n  missing.mat <- matrix(missingT$Et, nrow=length(missingT$Et), ncol=length(nonmissingT$Et), byrow=F); missing.mat\n  nonmissing.mat <- matrix(nonmissingT$Et, nrow=length(missingT$Et), ncol=length(nonmissingT$Et), byrow=T); nonmissing.mat\n  \n  W <- abs(missing.mat - nonmissing.mat)\n  rownames(W) <- paste0(\"Missing\", seq(nrow(W)))\n  colnames(W) <- paste0(\"NonMissing\", seq(ncol(W)))\n  \n  result <- t(sapply(seq(nrow(W)), function(i) {\n    j <- which.min(W[i,])\n    c(i, j)\n  }))\n  \n  alignments <- data.frame(missing = result[,1], nonmissing=result[,2])\n  #print(result)\n  \nreturn(as.vector(nonmissingT[result[,2],3]))\n}\n\n# Function to impute Reading Blanks\nimputeR <- function(sampleID){\n  library(dplyr)\n  tmp2 <- sampleID %>% select(Et, blank, temp)\n  \n  missingR = tmp2[is.na(tmp2$blank),]; missingR\n  nonmissingR = tmp2[!is.na(tmp2$blank),]; nonmissingR\n  \n  missing.mat <- matrix(missingR$Et, nrow=length(missingR$Et), ncol=length(nonmissingR$Et), byrow=F); missing.mat\n  nonmissing.mat <- matrix(nonmissingR$Et, nrow=length(missingR$Et), ncol=length(nonmissingR$Et), byrow=T); nonmissing.mat\n  \n  W <- abs(missing.mat - nonmissing.mat)\n  rownames(W) <- paste0(\"Missing\", seq(nrow(W)))\n  colnames(W) <- paste0(\"NonMissing\", seq(ncol(W)))\n  \n  result <- t(sapply(seq(nrow(W)), function(i) {\n    j <- which.min(W[i,])\n    c(i, j)\n  }))\n  \n  alignments <- data.frame(missingR = result[,1], nonmissingR=result[,2])\n  #print(result)\n  \n  return(as.vector(nonmissingR[result[,2],2]))\n}\n\n# Old version!\n#imputeR <- function(sampleID){\n#  library(dplyr)\n#  tmp <- sampleID %>% select(Et, Rblank, Temp)\n#  tmp$Et_Align <- Et_aligning(Test$Et) \n  \n  # non missing, keeping Rblank and Et_Align\n#  nonmissingR = tmp[!is.na(tmp$Rblank),c(2,4)]; nonmissingR \n#  missingR = tmp[is.na(tmp$Rblank),c(2,4)]; missingR\n#  nonmissingT = tmp[!is.na(tmp$Temp),c(3,4)]; nonmissingT\n#  missingT = tmp[is.na(tmp$Temp),c(3,4)]; missingT\n  \n#  tmpR = left_join(missingR, nonmissingR, by=\"Et_Align\")\n#  tmpT = left_join(missingT, nonmissingT, by=\"Et_Align\")\n#  tmpR$Rblank.y\n#}\n\n# Function to Select K\nKfun <- function(T=22, GSp = 2.65){\n  ifelse(T < 20, NA, \n  ifelse(T  == 20, 0.01365, \n  ifelse(T  == 21, 0.01348, \n  ifelse(T  == 22, 0.01332,\n  ifelse(T  == 23, 0.01317,\n  ifelse(T  == 24, 0.01301,\n  ifelse(T  == 25, 0.01289,\n  ifelse(T > 25, NA, NA))))))))\n}",
    "created" : 1471123516811.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1237588419",
    "id" : "C2B30B76",
    "lastKnownWriteTime" : 1471144206,
    "last_content_update" : 1471144206404,
    "path" : "~/github/SOPs/32_Soil_Texture_Analysis/Soil_functions/SoilEquiv_fun.R",
    "project_path" : "32_Soil_Texture_Analysis/Soil_functions/SoilEquiv_fun.R",
    "properties" : {
        "chunk_rendered_width" : "650",
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}